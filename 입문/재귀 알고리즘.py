 # 재귀호출 : factorial() 함수는 n-1의 팩토리얼 값을 구하기 위해 다시 자기 자신과 똑같은 factorial() 함수를 호출한다 이런 호출을 재귀호출이라고 한다.
# 직접재귀와 간저재귀 : 자신과 똑같은 함수를 호출하는 방식을 직접재귀, a가 b를 호출하고 b가 a를 호출하는 방식을 간접재귀
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 양의 정수 n의 팩토리얼 구하기

# from math import factorial


# def tactorial(n: int) -> int:
#     if n > 0:
#         return n * factorial(n-1)
#     else:
#         return 1
# if __name__ == '__main__':
#     n = int(input('출력할 팩토리얼 값을 입력하세요.:'))
#     print(f'{n}의 팩토리얼은 {factorial(n)}입니다')
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 유클리드 호재법으로 최대 공약수 구하기

# def gcd(x: int, y: int) -> int:
#     # 정숫값 x와 y의 최대 공약수를 반환
#     if y == 0:
#         return x
    
#     else:
#         return gcd(y, x % y)

# if __name__ == '__main__':
#     print('두 정숫값의 최대 공약수를 구합니다.') 
#     x = int(input('첫 번째 정숫값을 입력하세요:'))
#     y = int(input('두 번째 정수값을 입력하세요'))

#     print(f'두 정숫값을 최대 공약수는 {gcd(x,y)} 입니다.')
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 순수한 재귀 함수 구현하기

# def recur(n: int) -> int:
#     # 순수한 재귀 함수 구현
#     if n > 0:
#         recur(n-1)
#         print(n)
#         recur(n -2)
# x = int(input('정숫값을 입력하세요. :'))

# recur(x)
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 재귀 함수 호출을 거꾸로 출력하기

# def recur(n : int) -> int:
#     if n > 0:
#         recur(n-2)
#         print(n)
#         recur(n-1)
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 전에 작성했던 스택 클래스를 활용하여 비재귀적 함수 구현하기

# from 검색 알고리즘 import Stack

# def recur(n : int) -> int:
#     s = Stack(n)

#     while True:
#         if n > 0:
#             s.push(n)
#             n = n - 1
#             continue
#         if not s.is_empty():
#             n = s.pop()
#             print(n)
#             n = n - 2
#             continue
#         break

# x = int(input('정숫값을 입력하세요.:'))

# recur(x)
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 하노이의 탑 구하기

# def move(no :int, x : int, y : int) -> None:
#     # no는 옮겨야 할 원반의 개수, x는 시작기둥, y는 목표 기둥 번호
#     if no > 1:
#         move(no -1, x, 6 - x - y)

#     print(f'원반 [{no}을 {x} 기둥에서 {y}기둥으로 옮깁니다.')

#     if no > 1:
#         move(no -1, 6-x-y, y)
# print('하노이의 탑을 구현합니다')
# n = int(input('원반의 개수를 입력하세요.:'))
# move(n, 1, 3)
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 8퀸문제(1) 각 열에 퀸을 1개 배치하는 조합을 나열하기

# pos = [0] * 8  # 각 열에서 퀸의 위치를 출력

# def put() -> None:

#     for i in range(8):
#         print(f'{pos[i]:2}', end=' ')
#     print()

# def set(i: int) ->None:
#     for j in range(8):
#         pos[i] = j
#         if i == 7:
#             put()
#         else:
#             set(i+1)
# set(0)
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 행과 열에 퀸을 1개 배치하는 조합을 재귀적으로 나열하기

# pos = [0] * 8 # 각 열에서 퀸의 위치
# flag = [False] * 8 # 각 행에 퀸을 배치했는지 체크

# def put() -> None:
#     # 각 열에 배치한 퀸을 출력
#     for i in range(8):
#         print(f"{pos[i]:2 ,end=' '} ")
#     print()

# def set(i :int) -> None:
#     # i열에 알맞은 위치에 퀸을 배치
#     for j in range(8):
#         if not flag[j]:
#             pos[i] = j
#             if i == 7:
#                 put()
#             else:
#                 flag[j] = True
#                 set(i+1) # 다음 열에 퀸을 배치
#                 flag[j] = False
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 8퀸 문제 알고리즘 구현하기

# pos = [0] * 8
# flag_a = [False] * 8
# flag_b = [False] * 15
# flag_c = [False] * 15

# def put() -> None:
#     # 각 열에 배치한 퀸의 위치를 출력
#     for i in range(8):
#         print(f'{pos[i]:2}, end=' '')
#     print()

# def set(i : int) -> None:
#     for j in range(8):
#         if ( not flag_a[j] # j행에 퀸이 배치되지않았다면
#             and not flag_b[i+j] # 대각선 방향에 퀸이 배치되지 않았다면
#             and not flag_c[i-j+7]): # 대각선 방향으로 퀸이 배치되지 않았다면
#             pos[i] = j
#             if i == 7:
#                 put()
#             else:
#                 flag_a[j] = flag_b[i+j] = flag_c[i - j +7] = True
#                 set(i+1)
#                 flag_a[j] = flag_b[i+j] = flag_c[i - j +7] = False
# set(0)

